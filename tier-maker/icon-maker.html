<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>ç”»åƒé€£çµï¼‹ã‚­ãƒ£ãƒ—ã‚·ãƒ§ãƒ³ï¼ˆæœ€å¤§6æšï½œä¸¦ã¹æ›¿ãˆãƒ»90pxåŒ–ãƒ»æ­£æ–¹å½¢150pxï¼‰</title>
        <style>
            body {
                margin: 0;
                padding: 24px;
                font-family: system-ui, sans-serif;
                background: #0b1220;
                color: #e8eefc;
            }
            .wrap {
                max-width: 1000px;
                margin: 0 auto;
            }
            .panel {
                background: #111a2b;
                border: 1px solid #1f2a44;
                border-radius: 16px;
                box-shadow: 0 8px 40px rgba(0, 0, 0, 0.35);
                padding: 18px;
            }
            .file-button {
                border: 1px solid #1f2a44;
                color: #e8eefc;
                background: rgba(255, 255, 255, 0.06);
                padding: 10px 14px;
                border-radius: 12px;
                cursor: pointer;
                display: inline-block;
            }
            .dropzone {
                margin-top: 14px;
                border: 2px dashed #2b3d66;
                border-radius: 16px;
                padding: 22px;
                text-align: center;
                color: #a9b7d9;
                background: rgba(22, 34, 61, 0.35);
            }
            .controls {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                align-items: center;
                margin-top: 12px;
            }
            .select,
            .checkbox,
            .btn,
            .text {
                border: 1px solid #1f2a44;
                background: rgba(255, 255, 255, 0.06);
                color: #e8eefc;
                border-radius: 10px;
                padding: 8px 10px;
            }
            .text {
                min-width: 220px;
            }
            .number {
                width: 90px;
            }
            .btn {
                cursor: pointer;
            }
            .btn[disabled] {
                opacity: 0.5;
                cursor: not-allowed;
            }
            .preview-grid {
                margin-top: 16px;
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                gap: 16px;
            }
            .preview-card {
                background: #111a2b;
                border: 1px solid #1f2a44;
                border-radius: 12px;
                padding: 10px;
                position: relative;
            }
            .preview-card[draggable=\"true\"] {
                cursor: grab;
            }
            .preview-card.dragging {
                opacity: 0.6;
                outline: 2px dashed #5a8dff;
            }
            .order-badge {
                position: absolute;
                top: 8px;
                left: 8px;
                font-size: 12px;
                background: #5a8dff;
                color: #fff;
                border-radius: 999px;
                padding: 2px 7px;
            }
            .preview-card img {
                width: 100%;
                height: 150px;
                object-fit: contain;
                background: #0a0f1c;
                border-radius: 8px;
                margin-bottom: 6px;
            }
            .meta {
                font-size: 12px;
                color: #a9b7d9;
            }
            .meta strong {
                color: #e8eefc;
            }
            .hidden {
                display: none !important;
            }
            canvas {
                display: none;
            }
            label.small {
                font-size: 12px;
                color: #a9b7d9;
            }
        </style>
    </head>
    <body>
        <div class="wrap">
            <h1>ç”»åƒé€£çµï¼‹ã‚­ãƒ£ãƒ—ã‚·ãƒ§ãƒ³ï¼ˆæœ€å¤§6æšï¼‰</h1>
            <p>ä¸¦ã¹æ›¿ãˆå¯¾å¿œã€‚ç´ æã¯é«˜ã•90pxã«ç¸®å°ã—ã¦ã‹ã‚‰çµåˆã€‚æ­£æ–¹å½¢ä¿å­˜ã¯å¸¸ã«150Ã—150pxã€‚</p>

            <section class="panel" aria-label="ç”»åƒã®é¸æŠã¨é€£çµ">
                <label for="file" class="file-button">ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</label>
                <input id="file" type="file" accept="image/*" multiple class="hidden" />
                <div id="dropzone" class="dropzone" tabindex="0">ã“ã“ã«ç”»åƒã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã§ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦é †ç•ªå¤‰æ›´å¯ï¼‰</div>

                <div class="controls">
                    <label
                        >ãƒªã‚µã‚¤ã‚ºæ–¹å¼ï¼š
                        <select id="mode" class="select">
                            <option value="original">ç­‰å€ã§çµåˆï¼ˆåŸºæœ¬ã¯90pxä¸Šé™ã®å¾Œï¼‰</option>
                            <option value="fitMax">é«˜ã•ã‚’æœ€å¤§ã«åˆã‚ã›ã¦ç­‰é«˜ï¼ˆ90pxä¸Šé™ã®å¾Œï¼‰</option>
                            <option value="fitMin">é«˜ã•ã‚’æœ€å°ã«åˆã‚ã›ã¦ç­‰é«˜ï¼ˆ90pxä¸Šé™ã®å¾Œï¼‰</option>
                        </select>
                    </label>

                    <!-- ç­‰å€æ™‚ã®ç¸¦ä½ç½® -->
                    <label id="valignWrap" class="select">
                        ç¸¦ä½ç½®ï¼ˆç­‰å€æ™‚ï¼‰ï¼š
                        <select id="vAlign" class="select" style="margin-left: 6px">
                            <option value="center">ä¸­å¤®æƒãˆ</option>
                            <option value="bottom" selected>ä¸‹æƒãˆ</option>
                        </select>
                    </label>

                    <label class="checkbox"> <input type="checkbox" id="gapCheck" /> ç”»åƒé–“ã®ä½™ç™½ 8pxï¼ˆæ¨ªãƒ»ç¸¦ï¼‰ </label>
                    <label
                        >èƒŒæ™¯è‰²ï¼š
                        <input type="color" id="bgColor" value="#000000" class="select" />
                    </label>

                    <!-- å››è¾ºã®å¤–å´ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ï¼ˆå‡ºåŠ›ç”»åƒã®ä½™ç™½ï¼‰ -->
                    <label class="small">å·¦ä½™ç™½(px)ï¼š<input id="padLeft" type="number" class="select number" min="0" max="800" value="8" /></label>
                    <label class="small">å³ä½™ç™½(px)ï¼š<input id="padRight" type="number" class="select number" min="0" max="800" value="8" /></label>
                    <label class="small">ä¸Šä½™ç™½(px)ï¼š<input id="padTop" type="number" class="select number" min="0" max="800" value="12" /></label>
                    <label class="small">ä¸‹ä½™ç™½(px)ï¼š<input id="padBottom" type="number" class="select number" min="0" max="800" value="8" /></label>

                    <label class="checkbox"> <input type="checkbox" id="squareCheck" checked /> æ­£æ–¹å½¢ï¼ˆç”»åƒã¯ä¸Šä¸‹ä¸­å¤®ï¼ãƒ†ã‚­ã‚¹ãƒˆã¯ä¸‹å¯„ã›ï¼å®Œæˆã‚µã‚¤ã‚ºã¯å¸¸ã«150Ã—150ï¼‰ </label>

                    <button id="compose" class="btn" disabled>ğŸ§© é€£çµã—ã¦ä¿å­˜</button>
                    <button id="clear" class="btn" disabled>ã‚¯ãƒªã‚¢</button>
                </div>

                <!-- ã‚­ãƒ£ãƒ—ã‚·ãƒ§ãƒ³è¨­å®š -->
                <div class="controls">
                    <input id="capText" class="text" placeholder="ä¸‹éƒ¨ã«å…¥ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆï¼ˆç©ºãªã‚‰ãªã—ï¼è¤‡æ•°è¡Œã¯æ”¹è¡Œï¼‰" />
                    <label class="small">ã‚µã‚¤ã‚º(px)ï¼š<input id="capSize" type="number" class="select number" min="8" max="200" value="13" /></label>
                    <label class="small">è‰²ï¼š<input id="capColor" type="color" class="select" value="#ffffff" /></label>
                    <label class="checkbox"><input id="capBold" type="checkbox" checked /> å¤ªå­—</label>
                    <label class="small"
                        >ãƒ†ã‚­ã‚¹ãƒˆä½™ç™½(px)ï¼š
                        <input id="capMargin" type="number" class="select number" min="0" max="300" value="12" title="æ­£æ–¹å½¢æ™‚ã¯ä¸‹ä½™ç™½ï¼éæ­£æ–¹å½¢æ™‚ã¯ä¸Šä½™ç™½ã¨ã—ã¦æ‰±ã„ã¾ã™" />
                    </label>
                    <label class="small">æœ€å¤§è¡Œå¹…(%)ï¼š<input id="capWidthPct" type="number" class="select number" min="30" max="100" value="94" /></label>
                    <label class="small">è¡Œé–“ï¼š<input id="capLineH" type="number" class="select number" min="1.0" max="2.0" step="0.05" value="1.3" /></label>
                </div>

                <div id="preview-grid" class="preview-grid"></div>
                <canvas id="work"></canvas>
            </section>
        </div>

        <script>
            (function () {
                const MAX_FILES = 6;
                const TARGET_SQUARE = 150; // å‡ºåŠ›ã®æ­£æ–¹å½¢ç›®æ¨™ã‚µã‚¤ã‚º
                const CAP_HEIGHT_LIMIT = 90; // ç´ æã®é«˜ã•ä¸Šé™ï¼ˆâ‰§90ã¯90ã¸ç¸®å°ï¼‰

                const input = document.getElementById('file');
                const dropzone = document.getElementById('dropzone');
                const grid = document.getElementById('preview-grid');
                const composeBtn = document.getElementById('compose');
                const clearBtn = document.getElementById('clear');
                const modeSel = document.getElementById('mode');
                const vAlignSel = document.getElementById('vAlign');
                const vAlignWrap = document.getElementById('valignWrap');
                const gapCheck = document.getElementById('gapCheck');
                const bgColor = document.getElementById('bgColor');
                const work = document.getElementById('work');

                // å››è¾ºä½™ç™½
                const padLeftInp = document.getElementById('padLeft');
                const padRightInp = document.getElementById('padRight');
                const padTopInp = document.getElementById('padTop');
                const padBottomInp = document.getElementById('padBottom');

                // caption controls
                const capText = document.getElementById('capText');
                const capSize = document.getElementById('capSize');
                const capColor = document.getElementById('capColor');
                const capBold = document.getElementById('capBold');
                const capMargin = document.getElementById('capMargin'); // éæ­£æ–¹å½¢: ä¸Šä½™ç™½ / æ­£æ–¹å½¢: ä¸‹ä½™ç™½
                const capWidthPct = document.getElementById('capWidthPct');
                const capLineH = document.getElementById('capLineH');
                const squareCheck = document.getElementById('squareCheck');

                let images = []; // [{file, url, el, w, h}]
                let order = []; // ä¸¦ã³é †ï¼ˆimagesã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰

                function humanSize(bytes) {
                    const u = ['B', 'KB', 'MB', 'GB'];
                    let i = 0,
                        n = bytes;
                    while (n >= 1024 && i < u.length - 1) {
                        n /= 1024;
                        i++;
                    }
                    return `${n.toFixed(1)} ${u[i]}`;
                }

                function reset() {
                    images.forEach((it) => {
                        try {
                            URL.revokeObjectURL(it.url);
                        } catch (_) {}
                    });
                    images = [];
                    order = [];
                    grid.innerHTML = '';
                    composeBtn.disabled = true;
                    clearBtn.disabled = true;
                }

                function enableActions() {
                    const ok = images.length > 0;
                    composeBtn.disabled = !ok;
                    clearBtn.disabled = !ok;
                }

                function toggleVAlignVisibility() {
                    const isOriginal = modeSel.value === 'original';
                    vAlignWrap.style.opacity = isOriginal ? '1' : '.5';
                    vAlignWrap.style.pointerEvents = isOriginal ? 'auto' : 'none';
                    vAlignWrap.title = isOriginal ? '' : 'ç­‰å€ä»¥å¤–ã§ã¯ç„¡åŠ¹';
                }

                async function readFiles(fileList) {
                    reset();
                    const files = Array.from(fileList)
                        .slice(0, MAX_FILES)
                        .filter((f) => f.type.startsWith('image/'));
                    if (files.length === 0) return;

                    await Promise.all(
                        files.map(async (file) => {
                            const url = URL.createObjectURL(file);
                            const el = new Image();
                            el.decoding = 'async';
                            el.src = url;
                            await el.decode().catch(() => {});
                            images.push({ file, url, el, w: el.naturalWidth, h: el.naturalHeight });
                        })
                    );
                    order = images.map((_, i) => i);

                    renderPreview();
                    enableActions();
                }

                // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æç”»ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ã§ä¸¦ã¹æ›¿ãˆï¼‰
                function renderPreview() {
                    grid.innerHTML = '';
                    order.forEach((idx, pos) => {
                        const { file, url } = images[idx];
                        const card = document.createElement('div');
                        card.className = 'preview-card';
                        card.setAttribute('draggable', 'true');
                        card.dataset.index = String(idx);

                        const badge = document.createElement('div');
                        badge.className = 'order-badge';
                        badge.textContent = String(pos + 1);
                        card.appendChild(badge);

                        const img = document.createElement('img');
                        img.src = url;
                        const meta = document.createElement('div');
                        meta.className = 'meta';
                        meta.innerHTML = `ãƒ•ã‚¡ã‚¤ãƒ«å: <strong>${file.name}</strong><br>` + `ç¨®é¡: <strong>${file.type || 'ä¸æ˜'}</strong><br>` + `ã‚µã‚¤ã‚º: <strong>${humanSize(file.size)}</strong>`;
                        card.appendChild(img);
                        card.appendChild(meta);
                        grid.appendChild(card);
                    });

                    // DnD ä¸¦ã¹æ›¿ãˆ
                    let dragIdx = null;
                    grid.querySelectorAll('.preview-card').forEach((card) => {
                        card.addEventListener('dragstart', (e) => {
                            dragIdx = Number(card.dataset.index);
                            card.classList.add('dragging');
                            e.dataTransfer.setData('text/plain', String(dragIdx));
                        });
                        card.addEventListener('dragend', () => card.classList.remove('dragging'));
                    });
                    grid.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        const after = getDragAfterElement(grid, e.clientY);
                        const dragging = grid.querySelector('.preview-card.dragging');
                        if (!dragging) return;
                        if (after == null) {
                            grid.appendChild(dragging);
                        } else {
                            grid.insertBefore(dragging, after);
                        }
                    });
                    grid.addEventListener('drop', () => {
                        // DOMé †ã‹ã‚‰ order ã‚’å†æ§‹ç¯‰
                        const newOrder = [];
                        grid.querySelectorAll('.preview-card').forEach((c) => {
                            newOrder.push(Number(c.dataset.index));
                        });
                        order = newOrder;
                        renderPreview(); // ãƒãƒƒã‚¸ç•ªå·æ›´æ–°
                    });

                    function getDragAfterElement(container, y) {
                        const els = [...container.querySelectorAll('.preview-card:not(.dragging)')];
                        return els.reduce(
                            (closest, child) => {
                                const box = child.getBoundingClientRect();
                                const offset = y - box.top - box.height / 2;
                                if (offset < 0 && offset > closest.offset) {
                                    return { offset, element: child };
                                } else {
                                    return closest;
                                }
                            },
                            { offset: Number.NEGATIVE_INFINITY }
                        ).element;
                    }
                }

                // æ”¹è¡Œãƒ«ãƒ¼ãƒ«
                function computeRows(n) {
                    if (n <= 3) return [n];
                    if (n === 4) return [2, 2];
                    if (n === 5) return [3, 2];
                    return [3, 3]; // n===6
                }

                // ãƒ†ã‚­ã‚¹ãƒˆæŠ˜ã‚Šè¿”ã—
                function wrapText(ctx, text, maxWidth) {
                    const lines = [];
                    const rawLines = String(text).split(/\n/);
                    rawLines.forEach((raw) => {
                        const tokens = /\s/.test(raw) ? raw.split(/(\s+)/) : raw.split('');
                        let buf = '';
                        tokens.forEach((tok) => {
                            const t = buf + tok;
                            if (ctx.measureText(t).width <= maxWidth || buf === '') {
                                buf = t;
                            } else {
                                lines.push(buf);
                                buf = tok.trimStart();
                                if (ctx.measureText(buf).width > maxWidth) {
                                    let chunk = '';
                                    for (const ch of tok) {
                                        const tt = chunk + ch;
                                        if (ctx.measureText(tt).width <= maxWidth || chunk === '') {
                                            chunk = tt;
                                        } else {
                                            lines.push((buf ? buf : '') + chunk);
                                            buf = '';
                                            chunk = ch;
                                        }
                                    }
                                    buf += chunk;
                                }
                            }
                        });
                        if (buf) lines.push(buf);
                    });
                    return lines;
                }

                function composeAndDownload() {
                    if (images.length === 0) return;

                    const mode = modeSel.value;
                    const gap = gapCheck.checked ? 8 : 0;
                    const bg = bgColor.value || '#000000';
                    const vAlign = vAlignSel.value; // originalæ™‚ã®ã¿
                    const toSquare = document.getElementById('squareCheck').checked;

                    // å››è¾ºä½™ç™½
                    const padLeft = clamp(Number(padLeftInp.value), 0, 800, 24);
                    const padRight = clamp(Number(padRightInp.value), 0, 800, 24);
                    const padTop = clamp(Number(padTopInp.value), 0, 800, 24);
                    const padBottom = clamp(Number(padBottomInp.value), 0, 800, 24);

                    // ä¸¦ã³é †ã‚’é©ç”¨ã—ãŸé…åˆ—
                    const seq = order.map((i) => images[i]);

                    // --- ç´ æã®é«˜ã•ä¸Šé™ 90px ã‚’é©ç”¨ã—ã¦åŸºæœ¬æç”»ã‚µã‚¤ã‚ºã‚’ä½œã‚‹ ---
                    //   1) ã¾ãš 90px ä¸Šé™ã§å„ç”»åƒã®åŸºæº–ã‚µã‚¤ã‚ºã‚’æ±ºå®š
                    const baseSizes = seq.map((im) => {
                        const h0 = im.h >= CAP_HEIGHT_LIMIT ? CAP_HEIGHT_LIMIT : im.h;
                        const s = h0 / im.h;
                        return { bw: Math.round(im.w * s), bh: Math.round(im.h * s) }; // base width/height after 90px cap
                    });

                    //   2) ãã®å¾Œã« modeï¼ˆoriginal/fitMax/fitMinï¼‰ã‚’é©ç”¨
                    const Hmax = Math.max(...baseSizes.map((b) => b.bh));
                    const Hmin = Math.min(...baseSizes.map((b) => b.bh));
                    const targetH = mode === 'fitMax' ? Hmax : mode === 'fitMin' ? Hmin : null;

                    const drawSizes0 = baseSizes.map((b) => {
                        if (mode === 'original' || targetH == null) return { dw: b.bw, dh: b.bh };
                        const s = targetH / b.bh;
                        return { dw: Math.round(b.bw * s), dh: Math.round(b.bh * s) };
                    });

                    // è¡Œå‰²ã‚Šå½“ã¦ï¼ˆä¸¦ã³é †ã©ãŠã‚Šï¼‰
                    const rowsConf = computeRows(seq.length);
                    const rows = [];
                    let idx = 0;
                    rowsConf.forEach((count) => {
                        const idxs = Array.from({ length: count }, (_, k) => idx + k);
                        const sizes = idxs.map((i) => drawSizes0[i]);
                        const rowW = sizes.reduce((s, a) => s + a.dw, 0) + gap * Math.max(0, count - 1);
                        const rowH = Math.max(...sizes.map((s) => s.dh));
                        rows.push({ indexes: idxs, sizes, rowW, rowH });
                        idx += count;
                    });

                    // çµåˆç”»åƒï¼ˆãƒ†ã‚­ã‚¹ãƒˆã‚’é™¤ã„ãŸï¼‰å…¨ä½“ã®ã‚µã‚¤ã‚º
                    const maxRowW0 = Math.max(...rows.map((r) => r.rowW));
                    const imagesAreaH0 = rows.reduce((s, r) => s + r.rowH, 0) + gap * Math.max(0, rows.length - 1);

                    // --- ã‚­ãƒ£ãƒ—ã‚·ãƒ§ãƒ³è¨ˆæ¸¬ ---
                    const text = capText.value ?? '';
                    const hasCaption = text.trim().length > 0;
                    const fontPx = clamp(Number(capSize.value), 8, 200, 28);
                    const lineH = clamp(Number(capLineH.value), 1.0, 2.0, 1.3);
                    const ctxTmp = work.getContext('2d');
                    ctxTmp.font = `${capBold.checked ? '700 ' : ''}${fontPx}px system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans JP',sans-serif`;
                    const capMaxWidth = Math.max(0.3, Math.min(1.0, Number(capWidthPct.value) / 100 || 0.94)) * maxRowW0;
                    const lines = hasCaption ? wrapText(ctxTmp, text, capMaxWidth) : [];
                    const ascent = ctxTmp.measureText('Mg').actualBoundingBoxAscent || fontPx * 0.8;
                    const descent = ctxTmp.measureText('pq').actualBoundingBoxDescent || fontPx * 0.2;
                    const baseLineH = ascent + descent;
                    const capMarginVal = clamp(Number(capMargin.value), 0, 300, 12);
                    const textBlockH = hasCaption ? Math.ceil(lines.length * baseLineH * lineH) : 0;

                    // åŸºæœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„å¹…ï¼ˆãƒ†ã‚­ã‚¹ãƒˆè¡Œå¹…ã¯ images å¹…åŸºæº–ï¼‰
                    let contentW0 = padLeft + maxRowW0 + padRight;
                    let imagesAreaH = imagesAreaH0;
                    let maxRowW = maxRowW0;
                    let drawSizes = drawSizes0.map((x) => ({ ...x })); // å¾Œã§ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°åæ˜ 

                    // --- æ­£æ–¹å½¢ã‚µã‚¤ã‚ºèª¿æ•´ï¼ˆå¸¸ã«150Ã—150ï¼‰ ---
                    let canvasW = contentW0;
                    let canvasH;

                    if (toSquare) {
                        // ãƒ†ã‚­ã‚¹ãƒˆã¨ä½™ç™½ã¯å›ºå®šã€‚ç”»åƒéƒ¨åˆ†ã®ã¿å¯å¤‰ã§150ã«åˆã‚ã›ã‚‹ã€‚
                        // ã¾ãšã€Œæœ€å°ã§ã‚‚ 150ã€ã«ã™ã‚‹ï¼ˆå°ã•ã„å ´åˆã¯ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’æ‹¡ã’ã‚‹ã ã‘ï¼‰
                        const minW = TARGET_SQUARE;
                        const minH = TARGET_SQUARE;

                        // å¤§ãã„å ´åˆã¯ç”»åƒéƒ¨ã‚’ç¸®å°ã—ã¦ 150 ã«åˆã‚ã›ã‚‹
                        // 150ã«åã¾ã‚‹ãŸã‚ã®ç”»åƒç¸®å°ç‡ s ã‚’è¨ˆç®—ï¼ˆæ¨ªã¨ç¸¦ã®ä¸¡åˆ¶ç´„ï¼‰
                        const availW = Math.max(1, TARGET_SQUARE - padLeft - padRight);
                        const availH = Math.max(1, TARGET_SQUARE - padTop - padBottom - (hasCaption ? textBlockH + capMarginVal : 0));
                        let s = Math.min(1, availW / maxRowW0, availH / imagesAreaH0); // ç¸®å°ã®ã¿ï¼ˆæ‹¡å¤§ã¯ã—ãªã„ï¼‰

                        // ç¸®å°ã‚’åæ˜ 
                        if (s < 1) {
                            drawSizes = drawSizes0.map((d) => ({ dw: Math.round(d.dw * s), dh: Math.round(d.dh * s) }));
                            // è¡Œå†è¨ˆç®—
                            let i2 = 0;
                            const rows2 = [];
                            rowsConf.forEach((count) => {
                                const idxs = Array.from({ length: count }, (_, k) => i2 + k);
                                const sizes = idxs.map((i) => drawSizes[i]);
                                const rowW = sizes.reduce((sum, a) => sum + a.dw, 0) + gap * Math.max(0, count - 1);
                                const rowH = Math.max(...sizes.map((z) => z.dh));
                                rows2.push({ indexes: idxs, sizes, rowW, rowH });
                                i2 += count;
                            });
                            rows.length = 0;
                            rows.push(...rows2);
                            maxRowW = Math.max(...rows.map((r) => r.rowW));
                            imagesAreaH = rows.reduce((sum, r) => sum + r.rowH, 0) + gap * Math.max(0, rows.length - 1);
                        }

                        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã¯ã¡ã‚‡ã†ã© 150Ã—150ã€‚ä½™ç™½å€¤ã¯å¤‰æ›´ã—ãªã„ã€‚
                        canvasW = TARGET_SQUARE;
                        canvasH = TARGET_SQUARE;
                    } else {
                        // éæ­£æ–¹å½¢ï¼šè‡ªç„¶ãªã‚µã‚¤ã‚º
                        const captionH = hasCaption ? capMarginVal + textBlockH : 0;
                        canvasW = contentW0;
                        canvasH = padTop + imagesAreaH + captionH + padBottom;
                    }

                    // --- é…ç½®è¨ˆç®—ï¼ˆæ­£æ–¹å½¢æ™‚ï¼šç”»åƒã¯ä¸Šä¸‹ä¸­å¤®ã€ãƒ†ã‚­ã‚¹ãƒˆã¯ä¸‹å¯„ã›ï¼‰ ---
                    const ctx = work.getContext('2d');

                    // æ¨ªæ–¹å‘ã®ã‚»ãƒ³ã‚¿ãƒªãƒ³ã‚°ï¼ˆæ­£æ–¹å½¢æ™‚ã‚‚éæ­£æ–¹å½¢æ™‚ã‚‚ï¼‰
                    const offsetX = (canvasW - (padLeft + maxRowW + padRight)) / 2;

                    // ç”»åƒä¸Šç«¯Y
                    let imagesTopY;
                    let captionFirstBaselineY = null;

                    if (!toSquare) {
                        imagesTopY = padTop;
                        if (hasCaption) {
                            const captionTopY = imagesTopY + imagesAreaH;
                            captionFirstBaselineY = captionTopY + capMarginVal + baseLineH;
                        }
                    } else {
                        // ç”»åƒã¯ä¸Šä¸‹ä¸­å¤®ï¼ˆãƒ†ã‚­ã‚¹ãƒˆé ˜åŸŸã‚’é™¤ã„ãŸå¯ç”¨é ˜åŸŸå†…ã§ï¼‰
                        const captionBlockH = hasCaption ? textBlockH + capMarginVal : 0;
                        const imgAvailTop = padTop;
                        const imgAvailBottom = canvasH - padBottom - captionBlockH;
                        const imgAvailHeight = imgAvailBottom - imgAvailTop;
                        imagesTopY = imgAvailTop + Math.max(0, Math.round((imgAvailHeight - imagesAreaH) / 2));

                        // ãƒ†ã‚­ã‚¹ãƒˆã¯ä¸‹å¯„ã›
                        if (hasCaption) {
                            const lastBaseline = canvasH - padBottom - capMarginVal;
                            captionFirstBaselineY = lastBaseline - (lines.length - 1) * baseLineH * lineH;
                        }
                    }

                    // ã‚­ãƒ£ãƒ³ãƒã‚¹ç”Ÿæˆ
                    work.width = Math.max(1, Math.round(canvasW));
                    work.height = Math.max(1, Math.round(canvasH));
                    ctx.fillStyle = bg;
                    ctx.fillRect(0, 0, work.width, work.height);

                    // ç”»åƒã‚’æç”»ï¼ˆå„è¡Œã‚’æ¨ªä¸­å¤®å¯„ã›ï¼‰
                    let y = imagesTopY;
                    rows.forEach((row, rIdx) => {
                        const rowStartX = offsetX + padLeft + (maxRowW - row.rowW) / 2;
                        let x = rowStartX;
                        row.indexes.forEach((imgIndex, k) => {
                            const src = seq[imgIndex];
                            const dsz = drawSizes[imgIndex];
                            let yImg;
                            if (mode === 'original') {
                                yImg = vAlign === 'bottom' ? y + row.rowH - dsz.dh : Math.round(y + (row.rowH - dsz.dh) / 2);
                            } else {
                                yImg = Math.round(y + (row.rowH - dsz.dh) / 2);
                            }
                            ctx.drawImage(src.el, 0, 0, src.w, src.h, x, yImg, dsz.dw, dsz.dh);
                            x += dsz.dw + (k < row.sizes.length - 1 ? gap : 0);
                        });
                        y += row.rowH + (rIdx < rows.length - 1 ? gap : 0);
                    });

                    // ã‚­ãƒ£ãƒ—ã‚·ãƒ§ãƒ³
                    if (hasCaption) {
                        ctx.font = `${capBold.checked ? '700 ' : ''}${fontPx}px system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans JP',sans-serif`;
                        ctx.textBaseline = 'alphabetic';
                        ctx.textAlign = 'center';
                        ctx.fillStyle = capColor.value || '#ffffff';
                        const centerX = offsetX + padLeft + maxRowW / 2;

                        if (!toSquare) {
                            let baseline = captionFirstBaselineY;
                            lines.forEach((line) => {
                                ctx.fillText(line, centerX, Math.round(baseline));
                                baseline += baseLineH * lineH;
                            });
                        } else {
                            let baseline = captionFirstBaselineY;
                            lines.forEach((line) => {
                                ctx.fillText(line, centerX, Math.round(baseline));
                                baseline += baseLineH * lineH;
                            });
                        }
                    }

                    // ä¿å­˜ï¼ˆPNGï¼‰
                    const url = work.toDataURL('image/png');
                    const a = document.createElement('a');
                    const ts = new Date().toISOString().replace(/[:.]/g, '-');
                    a.href = url;
                    a.download = `concat-${seq.length}imgs-${toSquare ? '150sq' : 'free'}-${ts}.png`;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                }

                function clamp(v, lo, hi, def) {
                    v = Number.isFinite(v) ? v : def;
                    return Math.min(hi, Math.max(lo, v));
                }

                // Events
                input.addEventListener('change', (e) => {
                    if (e.target.files) readFiles(e.target.files);
                });
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach((t) => dropzone.addEventListener(t, (e) => e.preventDefault()));
                dropzone.addEventListener('drop', (e) => {
                    if (e.dataTransfer.files) readFiles(e.dataTransfer.files);
                });
                dropzone.addEventListener('click', () => input.click());
                composeBtn.addEventListener('click', composeAndDownload);
                clearBtn.addEventListener('click', reset);
                modeSel.addEventListener('change', toggleVAlignVisibility);

                // åˆæœŸ
                toggleVAlignVisibility();
            })();
        </script>
    </body>
</html>
